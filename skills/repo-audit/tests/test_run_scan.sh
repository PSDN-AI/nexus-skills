#!/usr/bin/env bash
# test_run_scan.sh — Integration tests for run_scan.sh
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
SCANNER_DIR="${1:?Usage: test_run_scan.sh <scanner_dir>}"

# shellcheck source=test_framework.sh
source "$SCRIPT_DIR/test_framework.sh"

RUN_SCAN="$SCANNER_DIR/run_scan.sh"

# Helper: create a minimal "clean" repo fixture
create_clean_repo() {
  # README with enough content
  local readme_content
  readme_content=$(printf 'This is a well-documented open-source project with useful content.\n%.0s' {1..20})
  create_file "README.md" "$readme_content"
  create_file_ln "LICENSE" "MIT License

Copyright (c) 2024 Test Project

Permission is hereby granted, free of charge, to any person obtaining a copy."
  create_file_ln "CONTRIBUTING.md" "# Contributing

We welcome contributions."
  create_file ".gitignore" "node_modules/
*.log
.env"
  create_file_ln "SECURITY.md" "# Security Policy

Report vulnerabilities to security@example.com"
  create_file_ln "CHANGELOG.md" "# Changelog

## 1.0.0
- Initial release"
}

# ============================================================
# Verdict logic tests
# ============================================================

test_clean_repo_ready() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  # Check the Overall Status line specifically (Verdict section always mentions NOT READY)
  assert_contains "$OUTPUT" "Overall Status**: ✅ READY" "clean repo shows READY"
  teardown_fixture_dir
}

test_critical_finding_not_ready() {
  setup_fixture_dir
  create_clean_repo
  create_file_ln ".env" "SECRET_KEY=supersecret123"
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "Overall Status**: ❌ NOT READY" "repo with .env is NOT READY"
  teardown_fixture_dir
}

test_high_finding_needs_work() {
  setup_fixture_dir
  # No LICENSE → HIGH finding, but no CRITICAL findings
  local readme_content
  readme_content=$(printf 'This is a well-documented open-source project with useful content.\n%.0s' {1..20})
  create_file "README.md" "$readme_content"
  create_file ".gitignore" "node_modules/"
  create_file_ln "CONTRIBUTING.md" "# Contributing"
  create_file_ln "SECURITY.md" "# Security"
  create_file_ln "CHANGELOG.md" "# Changelog"
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "Overall Status**: ⚠️ NEEDS WORK" "repo without LICENSE is NEEDS WORK"
  teardown_fixture_dir
}

# ============================================================
# Report structure tests
# ============================================================

test_report_has_header() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "# Repo Audit Report" "report has header"
  teardown_fixture_dir
}

test_report_has_summary_table() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "| Dimension" "report has summary table header"
  teardown_fixture_dir
}

test_report_has_all_dimensions() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "Security" "report has Security dimension"
  assert_contains "$OUTPUT" "Code Quality" "report has Code Quality dimension"
  assert_contains "$OUTPUT" "Documentation" "report has Documentation dimension"
  assert_contains "$OUTPUT" "Repo Hygiene" "report has Repo Hygiene dimension"
  assert_contains "$OUTPUT" "Legal/Compliance" "report has Legal/Compliance dimension"
  teardown_fixture_dir
}

test_report_has_verdict_section() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "## Verdict" "report has Verdict section"
  teardown_fixture_dir
}

test_report_has_recommended_actions() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "## Recommended Actions" "report has Recommended Actions section"
  teardown_fixture_dir
}

test_report_has_footer() {
  setup_fixture_dir
  create_clean_repo
  run_check "$RUN_SCAN"
  assert_contains "$OUTPUT" "Generated by" "report has footer"
  teardown_fixture_dir
}

# ============================================================
# Error handling tests
# ============================================================

test_no_args_exits_with_error() {
  local exit_code=0
  "$BASH" "$RUN_SCAN" > /dev/null 2>&1 || exit_code=$?
  assert_exit_code "$exit_code" 1 "no args exits with error"
}

test_invalid_path_exits_with_error() {
  local exit_code=0
  "$BASH" "$RUN_SCAN" "/nonexistent/path/$$" > /dev/null 2>&1 || exit_code=$?
  # Should exit non-zero (either 1 or 2 depending on how cd fails)
  if [[ "$exit_code" -ne 0 ]]; then
    _pass "invalid path exits with error (exit code: $exit_code)"
  else
    _fail "invalid path exits with error" "expected non-zero exit, got 0"
  fi
}

# ============================================================
# Severity count accuracy
# ============================================================

test_severity_counts_correct() {
  setup_fixture_dir
  create_clean_repo
  # Add a .env file → 1 CRITICAL in Security
  create_file_ln ".env" "SECRET=value123"
  run_check "$RUN_SCAN"
  # Security row should show at least 1 in Critical column
  # The summary table format: | Security | ❌ | N | ...
  assert_contains "$OUTPUT" "Overall Status**: ❌ NOT READY" "overall status reflects CRITICAL"
  # Verify the Security dimension shows ❌
  assert_matches "$OUTPUT" "Security.*❌" "Security dimension shows ❌"
  teardown_fixture_dir
}

# ============================================================
# Run all tests
# ============================================================

echo ">> run_scan.sh (integration)"
test_clean_repo_ready
test_critical_finding_not_ready
test_high_finding_needs_work
test_report_has_header
test_report_has_summary_table
test_report_has_all_dimensions
test_report_has_verdict_section
test_report_has_recommended_actions
test_report_has_footer
test_no_args_exits_with_error
test_invalid_path_exits_with_error
test_severity_counts_correct
print_summary
